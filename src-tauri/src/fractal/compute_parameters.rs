use num::Float;
use rand::Rng;

use super::{variations::*, Affine, Variation};

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize, Default)]
pub struct ComputeParameters<Scalar: Float> {
    pub final_variation: Option<Variations<Scalar>>,
    pub post_transform: Affine<Scalar>,
    pub variations: Vec<Variations<Scalar>>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub enum Variations<Scalar: Float> {
    Linear(LinearVariation<Scalar>),
    Spherical(SphericalVariation<Scalar>),
    Swirl(SwirlVariation<Scalar>),
    Horseshoe(HorseshoeVariation<Scalar>),
    Polar(PolarVariation<Scalar>),
    Handkerchief(HandkerchiefVariation<Scalar>),
    Heart(HeartVariation<Scalar>),
    Disc(DiscVariation<Scalar>),
    Spiral(SpiralVariation<Scalar>),
    Hyperbolic(HyperbolicVariation<Scalar>),
    Diamond(DiamondVariation<Scalar>),
    Ex(ExVariation<Scalar>),
    Julia(JuliaVariation<Scalar>),
    Bent(BentVariation<Scalar>),
    Waves(WavesVariation<Scalar>),
    Fisheye(FisheyeVariation<Scalar>),
    Popcorn(PopcornVariation<Scalar>),
    Exponential(ExponentialVariation<Scalar>),
    Power(PowerVariation<Scalar>),
    Cosine(CosineVariation<Scalar>),
    Rings(RingsVariation<Scalar>),
    Fan(FanVariation<Scalar>),
    Blob(BlobVariation<Scalar>),
    Pdj(PDJVariation<Scalar>),
    Fan2(Fan2Variation<Scalar>),
    Rings2(Rings2Variation<Scalar>),
    Eyefish(EyefishVariation<Scalar>),
    Bubble(BubbleVariation<Scalar>),
    Cylinder(CylinderVariation<Scalar>),
    Perspective(PerspectiveVariation<Scalar>),
    Noise(NoiseVariation<Scalar>),
    JuliaN(JuliaNVariation<Scalar>),
    JuliaScope(JuliaScopeVariation<Scalar>),
    Blur(BlurVariation<Scalar>),
    Gaussian(GaussianVariation<Scalar>),
    RadialBlur(RadialBlurVariation<Scalar>),
    Pie(PieVariation<Scalar>),
    Ngon(NgonVariation<Scalar>),
    Curl(CurlVariation<Scalar>),
    Rectangles(RectanglesVariation<Scalar>),
    Arch(ArchVariation<Scalar>),
    Tangent(TangentVariation<Scalar>),
    Square(SquareVariation<Scalar>),
    Rays(RaysVariation<Scalar>),
    Blade(BladeVariation<Scalar>),
    Secant(SecantVariation<Scalar>),
    Twintrian(TwintrianVariation<Scalar>),
    Cross(CrossVariation<Scalar>),
}

impl<Scalar: Float> Variation<Scalar> for Variations<Scalar> {
    fn apply(&self, point: &super::Point<Scalar>) -> super::Point<Scalar> {
        match self {
            Self::Linear(variation) => variation.apply(point),
            Self::Spherical(variation) => variation.apply(point),
            Self::Swirl(variation) => variation.apply(point),
            Self::Horseshoe(variation) => variation.apply(point),
            Self::Polar(variation) => variation.apply(point),
            Self::Handkerchief(variation) => variation.apply(point),
            Self::Heart(variation) => variation.apply(point),
            Self::Disc(variation) => variation.apply(point),
            Self::Spiral(variation) => variation.apply(point),
            Self::Hyperbolic(variation) => variation.apply(point),
            Self::Diamond(variation) => variation.apply(point),
            Self::Ex(variation) => variation.apply(point),
            Self::Julia(variation) => variation.apply(point),
            Self::Bent(variation) => variation.apply(point),
            Self::Waves(variation) => variation.apply(point),
            Self::Fisheye(variation) => variation.apply(point),
            Self::Popcorn(variation) => variation.apply(point),
            Self::Exponential(variation) => variation.apply(point),
            Self::Power(variation) => variation.apply(point),
            Self::Cosine(variation) => variation.apply(point),
            Self::Rings(variation) => variation.apply(point),
            Self::Fan(variation) => variation.apply(point),
            Self::Blob(variation) => variation.apply(point),
            Self::Pdj(variation) => variation.apply(point),
            Self::Fan2(variation) => variation.apply(point),
            Self::Rings2(variation) => variation.apply(point),
            Self::Eyefish(variation) => variation.apply(point),
            Self::Bubble(variation) => variation.apply(point),
            Self::Cylinder(variation) => variation.apply(point),
            Self::Perspective(variation) => variation.apply(point),
            Self::Noise(variation) => variation.apply(point),
            Self::JuliaN(variation) => variation.apply(point),
            Self::JuliaScope(variation) => variation.apply(point),
            Self::Blur(variation) => variation.apply(point),
            Self::Gaussian(variation) => variation.apply(point),
            Self::RadialBlur(variation) => variation.apply(point),
            Self::Pie(variation) => variation.apply(point),
            Self::Ngon(variation) => variation.apply(point),
            Self::Curl(variation) => variation.apply(point),
            Self::Rectangles(variation) => variation.apply(point),
            Self::Arch(variation) => variation.apply(point),
            Self::Tangent(variation) => variation.apply(point),
            Self::Square(variation) => variation.apply(point),
            Self::Rays(variation) => variation.apply(point),
            Self::Blade(variation) => variation.apply(point),
            Self::Secant(variation) => variation.apply(point),
            Self::Twintrian(variation) => variation.apply(point),
            Self::Cross(variation) => variation.apply(point),
        }
    }

    fn weight(&self) -> Scalar {
        match self {
            Self::Linear(variation) => variation.weight(),
            Self::Spherical(variation) => variation.weight(),
            Self::Swirl(variation) => variation.weight(),
            Self::Horseshoe(variation) => variation.weight(),
            Self::Polar(variation) => variation.weight(),
            Self::Handkerchief(variation) => variation.weight(),
            Self::Heart(variation) => variation.weight(),
            Self::Disc(variation) => variation.weight(),
            Self::Spiral(variation) => variation.weight(),
            Self::Hyperbolic(variation) => variation.weight(),
            Self::Diamond(variation) => variation.weight(),
            Self::Ex(variation) => variation.weight(),
            Self::Julia(variation) => variation.weight(),
            Self::Bent(variation) => variation.weight(),
            Self::Waves(variation) => variation.weight(),
            Self::Fisheye(variation) => variation.weight(),
            Self::Popcorn(variation) => variation.weight(),
            Self::Exponential(variation) => variation.weight(),
            Self::Power(variation) => variation.weight(),
            Self::Cosine(variation) => variation.weight(),
            Self::Rings(variation) => variation.weight(),
            Self::Fan(variation) => variation.weight(),
            Self::Blob(variation) => variation.weight(),
            Self::Pdj(variation) => variation.weight(),
            Self::Fan2(variation) => variation.weight(),
            Self::Rings2(variation) => variation.weight(),
            Self::Eyefish(variation) => variation.weight(),
            Self::Bubble(variation) => variation.weight(),
            Self::Cylinder(variation) => variation.weight(),
            Self::Perspective(variation) => variation.weight(),
            Self::Noise(variation) => variation.weight(),
            Self::JuliaN(variation) => variation.weight(),
            Self::JuliaScope(variation) => variation.weight(),
            Self::Blur(variation) => variation.weight(),
            Self::Gaussian(variation) => variation.weight(),
            Self::RadialBlur(variation) => variation.weight(),
            Self::Pie(variation) => variation.weight(),
            Self::Ngon(variation) => variation.weight(),
            Self::Curl(variation) => variation.weight(),
            Self::Rectangles(variation) => variation.weight(),
            Self::Arch(variation) => variation.weight(),
            Self::Tangent(variation) => variation.weight(),
            Self::Square(variation) => variation.weight(),
            Self::Rays(variation) => variation.weight(),
            Self::Blade(variation) => variation.weight(),
            Self::Secant(variation) => variation.weight(),
            Self::Twintrian(variation) => variation.weight(),
            Self::Cross(variation) => variation.weight(),
        }
    }

    fn affine(&self) -> Affine<Scalar> {
        match self {
            Self::Linear(variation) => variation.affine(),
            Self::Spherical(variation) => variation.affine(),
            Self::Swirl(variation) => variation.affine(),
            Self::Horseshoe(variation) => variation.affine(),
            Self::Polar(variation) => variation.affine(),
            Self::Handkerchief(variation) => variation.affine(),
            Self::Heart(variation) => variation.affine(),
            Self::Disc(variation) => variation.affine(),
            Self::Spiral(variation) => variation.affine(),
            Self::Hyperbolic(variation) => variation.affine(),
            Self::Diamond(variation) => variation.affine(),
            Self::Ex(variation) => variation.affine(),
            Self::Julia(variation) => variation.affine(),
            Self::Bent(variation) => variation.affine(),
            Self::Waves(variation) => variation.affine(),
            Self::Fisheye(variation) => variation.affine(),
            Self::Popcorn(variation) => variation.affine(),
            Self::Exponential(variation) => variation.affine(),
            Self::Power(variation) => variation.affine(),
            Self::Cosine(variation) => variation.affine(),
            Self::Rings(variation) => variation.affine(),
            Self::Fan(variation) => variation.affine(),
            Self::Blob(variation) => variation.affine(),
            Self::Pdj(variation) => variation.affine(),
            Self::Fan2(variation) => variation.affine(),
            Self::Rings2(variation) => variation.affine(),
            Self::Eyefish(variation) => variation.affine(),
            Self::Bubble(variation) => variation.affine(),
            Self::Cylinder(variation) => variation.affine(),
            Self::Perspective(variation) => variation.affine(),
            Self::Noise(variation) => variation.affine(),
            Self::JuliaN(variation) => variation.affine(),
            Self::JuliaScope(variation) => variation.affine(),
            Self::Blur(variation) => variation.affine(),
            Self::Gaussian(variation) => variation.affine(),
            Self::RadialBlur(variation) => variation.affine(),
            Self::Pie(variation) => variation.affine(),
            Self::Ngon(variation) => variation.affine(),
            Self::Curl(variation) => variation.affine(),
            Self::Rectangles(variation) => variation.affine(),
            Self::Arch(variation) => variation.affine(),
            Self::Tangent(variation) => variation.affine(),
            Self::Square(variation) => variation.affine(),
            Self::Rays(variation) => variation.affine(),
            Self::Blade(variation) => variation.affine(),
            Self::Secant(variation) => variation.affine(),
            Self::Twintrian(variation) => variation.affine(),
            Self::Cross(variation) => variation.affine(),
        }
    }

    fn name(&self) -> String {
        match self {
            Self::Linear(variation) => variation.name(),
            Self::Spherical(variation) => variation.name(),
            Self::Swirl(variation) => variation.name(),
            Self::Horseshoe(variation) => variation.name(),
            Self::Polar(variation) => variation.name(),
            Self::Handkerchief(variation) => variation.name(),
            Self::Heart(variation) => variation.name(),
            Self::Disc(variation) => variation.name(),
            Self::Spiral(variation) => variation.name(),
            Self::Hyperbolic(variation) => variation.name(),
            Self::Diamond(variation) => variation.name(),
            Self::Ex(variation) => variation.name(),
            Self::Julia(variation) => variation.name(),
            Self::Bent(variation) => variation.name(),
            Self::Waves(variation) => variation.name(),
            Self::Fisheye(variation) => variation.name(),
            Self::Popcorn(variation) => variation.name(),
            Self::Exponential(variation) => variation.name(),
            Self::Power(variation) => variation.name(),
            Self::Cosine(variation) => variation.name(),
            Self::Rings(variation) => variation.name(),
            Self::Fan(variation) => variation.name(),
            Self::Blob(variation) => variation.name(),
            Self::Pdj(variation) => variation.name(),
            Self::Fan2(variation) => variation.name(),
            Self::Rings2(variation) => variation.name(),
            Self::Eyefish(variation) => variation.name(),
            Self::Bubble(variation) => variation.name(),
            Self::Cylinder(variation) => variation.name(),
            Self::Perspective(variation) => variation.name(),
            Self::Noise(variation) => variation.name(),
            Self::JuliaN(variation) => variation.name(),
            Self::JuliaScope(variation) => variation.name(),
            Self::Blur(variation) => variation.name(),
            Self::Gaussian(variation) => variation.name(),
            Self::RadialBlur(variation) => variation.name(),
            Self::Pie(variation) => variation.name(),
            Self::Ngon(variation) => variation.name(),
            Self::Curl(variation) => variation.name(),
            Self::Rectangles(variation) => variation.name(),
            Self::Arch(variation) => variation.name(),
            Self::Tangent(variation) => variation.name(),
            Self::Square(variation) => variation.name(),
            Self::Rays(variation) => variation.name(),
            Self::Blade(variation) => variation.name(),
            Self::Secant(variation) => variation.name(),
            Self::Twintrian(variation) => variation.name(),
            Self::Cross(variation) => variation.name(),
        }
    }

    fn color(&self) -> super::Color<Scalar> {
        match self {
            Self::Linear(variation) => variation.color(),
            Self::Spherical(variation) => variation.color(),
            Self::Swirl(variation) => variation.color(),
            Self::Horseshoe(variation) => variation.color(),
            Self::Polar(variation) => variation.color(),
            Self::Handkerchief(variation) => variation.color(),
            Self::Heart(variation) => variation.color(),
            Self::Disc(variation) => variation.color(),
            Self::Spiral(variation) => variation.color(),
            Self::Hyperbolic(variation) => variation.color(),
            Self::Diamond(variation) => variation.color(),
            Self::Ex(variation) => variation.color(),
            Self::Julia(variation) => variation.color(),
            Self::Bent(variation) => variation.color(),
            Self::Waves(variation) => variation.color(),
            Self::Fisheye(variation) => variation.color(),
            Self::Popcorn(variation) => variation.color(),
            Self::Exponential(variation) => variation.color(),
            Self::Power(variation) => variation.color(),
            Self::Cosine(variation) => variation.color(),
            Self::Rings(variation) => variation.color(),
            Self::Fan(variation) => variation.color(),
            Self::Blob(variation) => variation.color(),
            Self::Pdj(variation) => variation.color(),
            Self::Fan2(variation) => variation.color(),
            Self::Rings2(variation) => variation.color(),
            Self::Eyefish(variation) => variation.color(),
            Self::Bubble(variation) => variation.color(),
            Self::Cylinder(variation) => variation.color(),
            Self::Perspective(variation) => variation.color(),
            Self::Noise(variation) => variation.color(),
            Self::JuliaN(variation) => variation.color(),
            Self::JuliaScope(variation) => variation.color(),
            Self::Blur(variation) => variation.color(),
            Self::Gaussian(variation) => variation.color(),
            Self::RadialBlur(variation) => variation.color(),
            Self::Pie(variation) => variation.color(),
            Self::Ngon(variation) => variation.color(),
            Self::Curl(variation) => variation.color(),
            Self::Rectangles(variation) => variation.color(),
            Self::Arch(variation) => variation.color(),
            Self::Tangent(variation) => variation.color(),
            Self::Square(variation) => variation.color(),
            Self::Rays(variation) => variation.color(),
            Self::Blade(variation) => variation.color(),
            Self::Secant(variation) => variation.color(),
            Self::Twintrian(variation) => variation.color(),
            Self::Cross(variation) => variation.color(),
        }
    }
}

impl ComputeParameters<f64> {
    pub fn choose(&self) -> Option<&Variations<f64>> {
        let mut rng = rand::thread_rng();
        let total_weight = self.variations.iter().map(|x| x.weight()).sum();
        if total_weight == 0f64 {
            return None;
        }

        let chosen_weight = rng.gen_range(0.0..(total_weight));
        let mut current_weight = chosen_weight;

        for variation in self.variations.iter() {
            current_weight = current_weight - variation.weight();
            if current_weight <= 0f64 {
                return Some(variation);
            }
        }
        return None;
    }
}
